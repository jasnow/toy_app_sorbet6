# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/site_ruby/all/site_ruby.rbi
#
# site_ruby-2.6.0
module Gem
end
class Gem::Dependency
end
module Bundler
end
module Bundler::SharedHelpers
  def bundler_ruby_lib; end
  def chdir(dir, &blk); end
  def clean_load_path; end
  def const_get_safely(constant_name, namespace); end
  def default_bundle_dir; end
  def default_gemfile; end
  def default_lockfile; end
  def digest(name); end
  def ensure_same_dependencies(spec, old_deps, new_deps); end
  def filesystem_access(path, action = nil, &block); end
  def find_directory(*names); end
  def find_file(*names); end
  def find_gemfile(order_matters = nil); end
  def gemfile_names; end
  def in_bundle?; end
  def major_deprecation(major_version, message); end
  def md5_available?; end
  def pretty_dependency(dep, print_source = nil); end
  def print_major_deprecations!; end
  def prints_major_deprecations?; end
  def pwd; end
  def resolve_path(path); end
  def root; end
  def search_up(*names); end
  def set_bundle_environment; end
  def set_bundle_variables; end
  def set_env(key, value); end
  def set_path; end
  def set_rubylib; end
  def set_rubyopt; end
  def trap(signal, override = nil, &block); end
  def validate_bundle_path; end
  def with_clean_git_env(&block); end
  def write_to_gemfile(gemfile_path, contents); end
  extend Bundler::SharedHelpers
end
class Bundler::Settings
  def [](name); end
  def all; end
  def allow_sudo?; end
  def app_cache_path; end
  def array_to_s(array); end
  def converted_value(value, key); end
  def credentials_for(uri); end
  def gem_mirrors; end
  def global_config_file; end
  def ignore_config?; end
  def initialize(root = nil); end
  def is_array(key); end
  def is_bool(name); end
  def is_num(key); end
  def key_for(key); end
  def load_config(config_file); end
  def local_config_file; end
  def local_overrides; end
  def locations(key); end
  def mirror_for(uri); end
  def parent_setting_for(name); end
  def path; end
  def pretty_values_for(exposed_key); end
  def self.normalize_uri(uri); end
  def set_command_option(key, value); end
  def set_command_option_if_given(key, value); end
  def set_global(key, value); end
  def set_key(raw_key, value, hash, file); end
  def set_local(key, value); end
  def specific_gem_for(name); end
  def split_specific_setting_for(name); end
  def temporary(update); end
  def to_array(value); end
  def to_bool(value); end
  def validate!; end
end
class Bundler::Settings::Path < Struct
  def append_ruby_scope; end
  def append_ruby_scope=(_); end
  def base_path; end
  def base_path_relative_to_pwd; end
  def default_install_uses_path; end
  def default_install_uses_path=(_); end
  def explicit_path; end
  def explicit_path=(_); end
  def path; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def system_path; end
  def system_path=(_); end
  def use_system_gems?; end
  def validate!; end
end
module Bundler::YAMLSerializer
  def convert_to_backward_compatible_key(key); end
  def dump(hash); end
  def dump_hash(hash); end
  def load(str); end
  def self.convert_to_backward_compatible_key(key); end
  def self.dump(hash); end
  def self.dump_hash(hash); end
  def self.load(str); end
end
class Gem::Ext::Builder
  def build_args; end
  def build_args=(arg0); end
  def build_error(build_dir, output, backtrace = nil); end
  def build_extension(extension, dest_path); end
  def build_extensions; end
  def builder_for(extension); end
  def initialize(spec, build_args = nil); end
  def self.class_name; end
  def self.make(dest_path, results); end
  def self.redirector; end
  def self.run(command, results, command_name = nil); end
  def write_gem_make_out(output); end
  include Gem::UserInteraction
end
class Bundler::FeatureFlag
  def allow_bundler_dependency_conflicts?; end
  def allow_offline_install?; end
  def auto_clean_without_path?; end
  def auto_config_jobs?; end
  def bundler_10_mode?; end
  def bundler_1_mode?; end
  def bundler_2_mode?; end
  def bundler_3_mode?; end
  def bundler_4_mode?; end
  def bundler_5_mode?; end
  def bundler_6_mode?; end
  def bundler_7_mode?; end
  def bundler_8_mode?; end
  def bundler_9_mode?; end
  def cache_all?; end
  def cache_command_is_package?; end
  def console_command?; end
  def default_cli_command; end
  def default_install_uses_path?; end
  def deployment_means_frozen?; end
  def disable_multisource?; end
  def error_on_stderr?; end
  def forget_cli_options?; end
  def github_https?; end
  def global_gem_cache?; end
  def global_path_appends_ruby_scope?; end
  def init_gems_rb?; end
  def initialize(bundler_version); end
  def list_command?; end
  def lockfile_uses_separate_rubygems_sources?; end
  def major_version; end
  def only_update_to_newer_versions?; end
  def path_relative_to_cwd?; end
  def plugins?; end
  def prefer_gems_rb?; end
  def print_only_version_number?; end
  def self.settings_flag(flag, &default); end
  def self.settings_method(name, key, &default); end
  def self.settings_option(key, &default); end
  def setup_makes_kernel_gem_public?; end
  def skip_default_git_sources?; end
  def specific_platform?; end
  def suppress_install_using_messages?; end
  def unlock_source_unlocks_spec?; end
  def update_requires_all_flag?; end
  def use_gem_version_promoter_for_major_updates?; end
  def viz_command?; end
end
class Bundler::Source
  def can_lock?(spec); end
  def dependency_names; end
  def dependency_names=(arg0); end
  def dependency_names_to_double_check; end
  def double_check_for(*arg0); end
  def earlier_version?(spec_version, locked_spec_version); end
  def extension_cache_path(spec); end
  def extension_cache_slug(_); end
  def include?(other); end
  def inspect; end
  def path?; end
  def print_using_message(message); end
  def unmet_deps; end
  def version_color(spec_version, locked_spec_version); end
  def version_message(spec); end
end
class Bundler::Source::Path < Bundler::Source
  def ==(other); end
  def app_cache_dirname; end
  def app_cache_path(custom_path = nil); end
  def cache(spec, custom_path = nil); end
  def cached!; end
  def eql?(other); end
  def expand(somepath); end
  def expanded_original_path; end
  def expanded_path; end
  def generate_bin(spec, options = nil); end
  def has_app_cache?; end
  def hash; end
  def initialize(options); end
  def install(spec, options = nil); end
  def load_gemspec(file); end
  def load_spec_files; end
  def local_specs(*arg0); end
  def lockfile_path; end
  def name; end
  def name=(arg0); end
  def options; end
  def original_path; end
  def path; end
  def relative_path(path = nil); end
  def remote!; end
  def root; end
  def root_path; end
  def self.from_lock(options); end
  def specs; end
  def to_lock; end
  def to_s; end
  def validate_spec(spec); end
  def version; end
  def version=(arg0); end
end
class Bundler::Source::Git < Bundler::Source::Path
  def ==(other); end
  def allow_git_ops?; end
  def app_cache_dirname; end
  def base_name; end
  def branch; end
  def cache(spec, custom_path = nil); end
  def cache_path; end
  def cached?; end
  def cached_revision; end
  def eql?(other); end
  def extension_cache_slug(_); end
  def extension_dir_name; end
  def fetch; end
  def git_proxy; end
  def git_scope; end
  def has_app_cache?; end
  def hash; end
  def initialize(options); end
  def install(spec, options = nil); end
  def install_path; end
  def load_gemspec(file); end
  def load_spec_files; end
  def local?; end
  def local_override!(path); end
  def name; end
  def options; end
  def path; end
  def ref; end
  def requires_checkout?; end
  def revision; end
  def self.from_lock(options); end
  def serialize_gemspecs_in(destination); end
  def set_local!(path); end
  def shortref_for_display(ref); end
  def shortref_for_path(ref); end
  def specs(*arg0); end
  def submodules; end
  def to_lock; end
  def to_s; end
  def unlock!; end
  def uri; end
  def uri_hash; end
  def validate_spec(_spec); end
end
class Bundler::Source::Rubygems < Bundler::Source
  def ==(other); end
  def add_remote(source); end
  def api_fetchers; end
  def builtin_gem?(spec); end
  def cache(spec, custom_path = nil); end
  def cache_globally(spec, local_cache_path); end
  def cache_path; end
  def cached!; end
  def cached_built_in_gem(spec); end
  def cached_gem(spec); end
  def cached_path(spec); end
  def cached_specs; end
  def caches; end
  def can_lock?(spec); end
  def credless_remotes; end
  def dependency_names_to_double_check; end
  def double_check_for(unmet_dependency_names); end
  def download_cache_path(spec); end
  def download_gem(spec, download_path); end
  def eql?(other); end
  def equivalent_remotes?(other_remotes); end
  def extension_cache_slug(spec); end
  def fetch_gem(spec); end
  def fetch_names(fetchers, dependency_names, index, override_dupes); end
  def fetchers; end
  def hash; end
  def include?(o); end
  def initialize(options = nil); end
  def install(spec, opts = nil); end
  def installed?(spec); end
  def installed_specs; end
  def loaded_from(spec); end
  def name; end
  def normalize_uri(uri); end
  def options; end
  def remote!; end
  def remote_specs; end
  def remotes; end
  def remotes_for_spec(spec); end
  def remove_auth(remote); end
  def replace_remotes(other_remotes, allow_equivalent = nil); end
  def requires_sudo?; end
  def rubygems_dir; end
  def self.from_lock(options); end
  def specs; end
  def suppress_configured_credentials(remote); end
  def to_lock; end
  def to_s; end
  def unmet_deps; end
end
class Bundler::LockfileParser
  def bundler_version; end
  def dependencies; end
  def initialize(lockfile); end
  def parse_bundled_with(line); end
  def parse_dependency(line); end
  def parse_platform(line); end
  def parse_ruby(line); end
  def parse_source(line); end
  def parse_spec(line); end
  def platforms; end
  def ruby_version; end
  def self.sections_in_lockfile(lockfile_contents); end
  def self.sections_to_ignore(base_version = nil); end
  def self.unknown_sections_in_lockfile(lockfile_contents); end
  def sources; end
  def specs; end
  def warn_for_outdated_bundler_version; end
end
class Bundler::Definition
  def add_current_platform; end
  def add_platform(platform); end
  def additional_base_requirements_for_resolve; end
  def change_reason; end
  def compute_requires; end
  def concat_ruby_version_requirements(ruby_version, ruby_versions = nil); end
  def converge_dependencies; end
  def converge_locals; end
  def converge_locked_specs; end
  def converge_path_source_to_gemspec_source(source); end
  def converge_path_sources_to_gemspec_sources; end
  def converge_paths; end
  def converge_rubygems_sources; end
  def converge_sources; end
  def current_dependencies; end
  def dependencies; end
  def dependencies_for_source_changed?(source, locked_source = nil); end
  def double_check_for_index(idx, dependency_names); end
  def ensure_equivalent_gemfile_and_lockfile(explicit_flag = nil); end
  def equivalent_rubygems_remotes?(source); end
  def expand_dependencies(dependencies, remote = nil); end
  def expanded_dependencies; end
  def extract_gem_info(error); end
  def find_indexed_specs(current_spec); end
  def find_resolved_spec(current_spec); end
  def gem_version_promoter; end
  def gemfiles; end
  def groups; end
  def has_local_dependencies?; end
  def has_rubygems_remotes?; end
  def in_locked_deps?(dep, locked_dep); end
  def index; end
  def initialize(lockfile, dependencies, sources, unlock, ruby_version = nil, optional_groups = nil, gemfiles = nil); end
  def lock(file, preserve_unknown_sections = nil); end
  def locked_bundler_version; end
  def locked_deps; end
  def locked_gems; end
  def locked_ruby_version; end
  def locked_ruby_version_object; end
  def lockfile; end
  def lockfiles_equal?(current, proposed, preserve_unknown_sections); end
  def metadata_dependencies; end
  def missing_specs; end
  def missing_specs?; end
  def new_platform?; end
  def new_specs; end
  def nothing_changed?; end
  def pinned_spec_names(skip = nil); end
  def platforms; end
  def pretty_dep(dep, source = nil); end
  def remove_platform(platform); end
  def removed_specs; end
  def requested_dependencies; end
  def requested_groups; end
  def requested_specs; end
  def requires; end
  def resolve; end
  def resolve_remotely!; end
  def resolve_with_cache!; end
  def ruby_version; end
  def satisfies_locked_spec?(dep); end
  def self.build(gemfile, lockfile, unlock); end
  def source_requirements; end
  def sources; end
  def spec_git_paths; end
  def specs; end
  def specs_changed?(source); end
  def specs_for(groups); end
  def specs_for_source_changed?(source); end
  def to_lock; end
  def unlocking?; end
  def validate_platforms!; end
  def validate_ruby!; end
  def validate_runtime!; end
  include Bundler::GemHelpers
end
class Bundler::Dependency < Gem::Dependency
  def autorequire; end
  def current_env?; end
  def current_platform?; end
  def gem_platforms(valid_platforms); end
  def gemfile; end
  def groups; end
  def initialize(name, version, options = nil, &blk); end
  def platforms; end
  def should_include?; end
  def specific?; end
  def to_lock; end
end
module Bundler::RubyDsl
  def ruby(*ruby_version); end
end
class Bundler::Dsl
  def add_git_sources; end
  def check_primary_source_safety(source_list); end
  def dependencies; end
  def dependencies=(arg0); end
  def env(name); end
  def eval_gemfile(gemfile, contents = nil); end
  def gem(name, *args); end
  def gemfile_root; end
  def gemspec(opts = nil); end
  def gemspecs; end
  def git(uri, options = nil, &blk); end
  def git_source(name, &block); end
  def github(repo, options = nil); end
  def group(*args, &blk); end
  def initialize; end
  def install_if(*args); end
  def method_missing(name, *args); end
  def normalize_group_options(opts, groups); end
  def normalize_hash(opts); end
  def normalize_options(name, version, opts); end
  def normalize_source(source); end
  def path(path, options = nil, &blk); end
  def platform(*platforms); end
  def platforms(*platforms); end
  def plugin(*args); end
  def self.evaluate(gemfile, lockfile, unlock); end
  def source(source, *args, &blk); end
  def to_definition(lockfile, unlock); end
  def valid_keys; end
  def validate_keys(command, opts, valid_keys); end
  def warn_deprecated_git_source(name, replacement, additional_message = nil); end
  def with_source(source); end
  include Bundler::RubyDsl
end
class Bundler::Dsl::DSLError < Bundler::GemfileError
  def backtrace; end
  def contents; end
  def description; end
  def dsl_path; end
  def initialize(description, dsl_path, backtrace, contents = nil); end
  def parse_line_number_from_description; end
  def status_code; end
  def to_s; end
end
class Bundler::SourceList
  def add_git_source(options = nil); end
  def add_path_source(options = nil); end
  def add_plugin_source(source, options = nil); end
  def add_rubygems_remote(uri); end
  def add_rubygems_source(options = nil); end
  def add_source_to_list(source, list); end
  def all_sources; end
  def cached!; end
  def combine_rubygems_sources; end
  def default_source; end
  def equal_source?(source, other_source); end
  def equal_sources?(lock_sources, replacement_sources); end
  def equivalent_rubygems_sources?(lock_sources, replacement_sources); end
  def equivalent_source?(source, other_source); end
  def equivalent_sources?(lock_sources, replacement_sources); end
  def get(source); end
  def git_sources; end
  def global_rubygems_source; end
  def global_rubygems_source=(uri); end
  def initialize; end
  def lock_sources; end
  def metadata_source; end
  def path_sources; end
  def plugin_sources; end
  def remote!; end
  def replace_sources!(replacement_sources); end
  def rubygems_aggregate_class; end
  def rubygems_primary_remotes; end
  def rubygems_remotes; end
  def rubygems_sources; end
  def source_list_for(source); end
  def warn_on_git_protocol(source); end
end
class Bundler::Source::Metadata < Bundler::Source
  def ==(other); end
  def cached!; end
  def eql?(other); end
  def hash; end
  def install(spec, _opts = nil); end
  def options; end
  def remote!; end
  def specs; end
  def to_s; end
  def version_message(spec); end
end
class Bundler::LazySpecification
  def ==(other); end
  def __materialize__; end
  def dependencies; end
  def full_name; end
  def git_version; end
  def identifier; end
  def initialize(name, version, platform, source = nil); end
  def method_missing(method, *args, &blk); end
  def name; end
  def platform; end
  def remote; end
  def remote=(arg0); end
  def respond_to?(*args); end
  def satisfies?(dependency); end
  def source; end
  def source=(arg0); end
  def to_ary; end
  def to_lock; end
  def to_s; end
  def version; end
  include Bundler::MatchPlatform
end
class Bundler::LazySpecification::Identifier < Struct
  def <=>(other); end
  def dependencies; end
  def dependencies=(_); end
  def name; end
  def name=(_); end
  def platform; end
  def platform=(_); end
  def platform_string; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def source; end
  def source=(_); end
  def version; end
  def version=(_); end
  include Comparable
end
class Bundler::Index
  def <<(spec); end
  def ==(other); end
  def [](query, base = nil); end
  def add_source(index); end
  def all_specs; end
  def dependencies_eql?(spec, other_spec); end
  def dependency_names; end
  def each(&blk); end
  def empty?; end
  def initialize; end
  def initialize_copy(o); end
  def inspect; end
  def local_search(query, base = nil); end
  def search(query, base = nil); end
  def search_all(name); end
  def search_by_dependency(dependency, base = nil); end
  def search_by_spec(spec); end
  def self.build; end
  def self.sort_specs(specs); end
  def size; end
  def sort_specs(specs); end
  def sources; end
  def spec_names; end
  def specs; end
  def specs_by_name(name); end
  def unmet_dependency_names; end
  def unsorted_search(query, base); end
  def use(other, override_dupes = nil); end
  include Enumerable
end
class Bundler::SpecSet
  def <<(*args, &block); end
  def [](key); end
  def []=(key, value); end
  def add(*args, &block); end
  def each(*args, &block); end
  def empty?(*args, &block); end
  def extract_circular_gems(error); end
  def find_by_name_and_platform(name, platform); end
  def for(dependencies, skip = nil, check = nil, match_current_platform = nil, raise_on_missing = nil); end
  def initialize(specs); end
  def length(*args, &block); end
  def lookup; end
  def materialize(deps, missing_specs = nil); end
  def materialized_for_all_platforms; end
  def merge(set); end
  def remove(*args, &block); end
  def size(*args, &block); end
  def sort!; end
  def sorted; end
  def spec_for_dependency(dep, match_current_platform); end
  def to_a; end
  def to_hash; end
  def tsort_each_child(s); end
  def tsort_each_node; end
  def valid_for?(deps); end
  def what_required(spec); end
  extend Forwardable
  include TSort
end
module Bundler::Molinillo
end
module Bundler::Molinillo::Compatibility
  def flat_map(enum, &blk); end
  def self.flat_map(enum, &blk); end
end
module Bundler::Molinillo::Delegates
end
module Bundler::Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end
  def dependencies_for(specification); end
  def name_for(dependency); end
  def name_for_explicit_dependency_source; end
  def name_for_locking_dependency_source; end
  def requirement_satisfied_by?(requirement, activated, spec); end
  def search_for(dependency); end
  def sort_dependencies(dependencies, activated, conflicts); end
  def with_no_such_dependency_error_handling; end
end
class Bundler::Molinillo::ResolverError < StandardError
end
class Bundler::Molinillo::NoSuchDependencyError < Bundler::Molinillo::ResolverError
  def dependency; end
  def dependency=(arg0); end
  def initialize(dependency, required_by = nil); end
  def message; end
  def required_by; end
  def required_by=(arg0); end
end
class Bundler::Molinillo::CircularDependencyError < Bundler::Molinillo::ResolverError
  def dependencies; end
  def initialize(vertices); end
end
class Bundler::Molinillo::VersionConflict < Bundler::Molinillo::ResolverError
  def conflicts; end
  def initialize(conflicts, specification_provider); end
  def message_with_trees(opts = nil); end
  def specification_provider; end
  include Bundler::Molinillo::Delegates::SpecificationProvider
end
class Bundler::Molinillo::DependencyGraph
  def ==(other); end
  def add_child_vertex(name, payload, parent_names, requirement); end
  def add_edge(origin, destination, requirement); end
  def add_edge_no_circular(origin, destination, requirement); end
  def add_vertex(name, payload, root = nil); end
  def delete_edge(edge); end
  def detach_vertex_named(name); end
  def each; end
  def initialize; end
  def initialize_copy(other); end
  def inspect; end
  def log; end
  def rewind_to(tag); end
  def root_vertex_named(name); end
  def self.tsort(vertices); end
  def set_payload(name, payload); end
  def tag(tag); end
  def to_dot(options = nil); end
  def tsort_each_child(vertex, &block); end
  def tsort_each_node; end
  def vertex_named(name); end
  def vertices; end
  include Enumerable
  include TSort
end
class Bundler::Molinillo::DependencyGraph::Action
  def down(graph); end
  def next; end
  def next=(arg0); end
  def previous; end
  def previous=(arg0); end
  def self.action_name; end
  def up(graph); end
end
class Bundler::Molinillo::DependencyGraph::AddEdgeNoCircular < Bundler::Molinillo::DependencyGraph::Action
  def delete_first(array, item); end
  def destination; end
  def down(graph); end
  def initialize(origin, destination, requirement); end
  def make_edge(graph); end
  def origin; end
  def requirement; end
  def self.action_name; end
  def up(graph); end
end
class Bundler::Molinillo::DependencyGraph::AddVertex < Bundler::Molinillo::DependencyGraph::Action
  def down(graph); end
  def initialize(name, payload, root); end
  def name; end
  def payload; end
  def root; end
  def self.action_name; end
  def up(graph); end
end
class Bundler::Molinillo::DependencyGraph::DeleteEdge < Bundler::Molinillo::DependencyGraph::Action
  def destination_name; end
  def down(graph); end
  def initialize(origin_name, destination_name, requirement); end
  def make_edge(graph); end
  def origin_name; end
  def requirement; end
  def self.action_name; end
  def up(graph); end
end
class Bundler::Molinillo::DependencyGraph::DetachVertexNamed < Bundler::Molinillo::DependencyGraph::Action
  def down(graph); end
  def initialize(name); end
  def name; end
  def self.action_name; end
  def up(graph); end
end
class Bundler::Molinillo::DependencyGraph::SetPayload < Bundler::Molinillo::DependencyGraph::Action
  def down(graph); end
  def initialize(name, payload); end
  def name; end
  def payload; end
  def self.action_name; end
  def up(graph); end
end
class Bundler::Molinillo::DependencyGraph::Tag < Bundler::Molinillo::DependencyGraph::Action
  def down(_graph); end
  def initialize(tag); end
  def self.action_name; end
  def tag; end
  def up(_graph); end
end
class Bundler::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end
  def add_vertex(graph, name, payload, root); end
  def delete_edge(graph, origin_name, destination_name, requirement); end
  def detach_vertex_named(graph, name); end
  def each; end
  def initialize; end
  def pop!(graph); end
  def push_action(graph, action); end
  def reverse_each; end
  def rewind_to(graph, tag); end
  def set_payload(graph, name, payload); end
  def tag(graph, tag); end
  extend Enumerable
end
class Bundler::Molinillo::DependencyGraph::Vertex
  def ==(other); end
  def _path_to?(other, visited = nil); end
  def ancestor?(other); end
  def descendent?(other); end
  def eql?(other); end
  def explicit_requirements; end
  def hash; end
  def incoming_edges; end
  def incoming_edges=(arg0); end
  def initialize(name, payload); end
  def inspect; end
  def is_reachable_from?(other); end
  def name; end
  def name=(arg0); end
  def outgoing_edges; end
  def outgoing_edges=(arg0); end
  def path_to?(other); end
  def payload; end
  def payload=(arg0); end
  def predecessors; end
  def recursive_predecessors; end
  def recursive_successors; end
  def requirements; end
  def root; end
  def root=(arg0); end
  def root?; end
  def shallow_eql?(other); end
  def successors; end
end
class Bundler::Molinillo::DependencyGraph::Edge < Struct
  def destination; end
  def destination=(_); end
  def origin; end
  def origin=(_); end
  def requirement; end
  def requirement=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Bundler::Molinillo::ResolutionState < Struct
  def activated; end
  def activated=(_); end
  def conflicts; end
  def conflicts=(_); end
  def depth; end
  def depth=(_); end
  def name; end
  def name=(_); end
  def possibilities; end
  def possibilities=(_); end
  def requirement; end
  def requirement=(_); end
  def requirements; end
  def requirements=(_); end
  def self.[](*arg0); end
  def self.empty; end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def unused_unwind_options; end
  def unused_unwind_options=(_); end
end
class Bundler::Molinillo::DependencyState < Bundler::Molinillo::ResolutionState
  def pop_possibility_state; end
end
class Bundler::Molinillo::PossibilityState < Bundler::Molinillo::ResolutionState
end
module Bundler::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end
  def dependencies_for(specification); end
  def name_for(dependency); end
  def name_for_explicit_dependency_source; end
  def name_for_locking_dependency_source; end
  def requirement_satisfied_by?(requirement, activated, spec); end
  def search_for(dependency); end
  def sort_dependencies(dependencies, activated, conflicts); end
end
module Bundler::Molinillo::Delegates::ResolutionState
  def activated; end
  def conflicts; end
  def depth; end
  def name; end
  def possibilities; end
  def requirement; end
  def requirements; end
  def unused_unwind_options; end
end
class Bundler::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end
  def resolve(requested, base = nil); end
  def resolver_ui; end
  def specification_provider; end
end
class Bundler::Molinillo::Resolver::Resolution
  def activate_new_spec; end
  def attempt_to_activate; end
  def attempt_to_filter_existing_spec(vertex); end
  def base; end
  def binding_requirement_in_set?(requirement, possible_binding_requirements, possibilities); end
  def binding_requirements_for_conflict(conflict); end
  def build_details_for_unwind; end
  def conflict_fixing_possibilities?(state, binding_requirements); end
  def create_conflict(underlying_error = nil); end
  def debug(depth = nil, &block); end
  def end_resolution; end
  def filter_possibilities_after_unwind(unwind_details); end
  def filter_possibilities_for_parent_unwind(unwind_details); end
  def filter_possibilities_for_primary_unwind(unwind_details); end
  def filtered_possibility_set(vertex); end
  def find_state_for(requirement); end
  def group_possibilities(possibilities); end
  def handle_missing_or_push_dependency_state(state); end
  def indicate_progress; end
  def initial_state; end
  def initialize(specification_provider, resolver_ui, requested, base); end
  def iteration_rate; end
  def iteration_rate=(arg0); end
  def locked_requirement_named(requirement_name); end
  def locked_requirement_possibility_set(requirement, activated = nil); end
  def original_requested; end
  def parent_of(requirement); end
  def possibilities_for_requirement(requirement, activated = nil); end
  def possibility; end
  def possibility_satisfies_requirements?(possibility, requirements); end
  def process_topmost_state; end
  def push_state_for_requirements(new_requirements, requires_sort = nil, new_activated = nil); end
  def raise_error_unless_state(conflicts); end
  def require_nested_dependencies_for(possibility_set); end
  def requirement_for_existing_name(name); end
  def requirement_tree_for(requirement); end
  def requirement_trees; end
  def resolve; end
  def resolve_activated_specs; end
  def resolver_ui; end
  def specification_provider; end
  def start_resolution; end
  def started_at; end
  def started_at=(arg0); end
  def state; end
  def states; end
  def states=(arg0); end
  def unwind_for_conflict; end
  def unwind_options_for_requirements(binding_requirements); end
  include Bundler::Molinillo::Delegates::ResolutionState
  include Bundler::Molinillo::Delegates::SpecificationProvider
end
class Bundler::Molinillo::Resolver::Resolution::Conflict < Struct
  def activated_by_name; end
  def activated_by_name=(_); end
  def existing; end
  def existing=(_); end
  def locked_requirement; end
  def locked_requirement=(_); end
  def possibility; end
  def possibility_set; end
  def possibility_set=(_); end
  def requirement; end
  def requirement=(_); end
  def requirement_trees; end
  def requirement_trees=(_); end
  def requirements; end
  def requirements=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def underlying_error; end
  def underlying_error=(_); end
end
class Bundler::Molinillo::Resolver::Resolution::PossibilitySet < Struct
  def dependencies; end
  def dependencies=(_); end
  def latest_version; end
  def possibilities; end
  def possibilities=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def to_s; end
end
class Bundler::Molinillo::Resolver::Resolution::UnwindDetails < Struct
  def <=>(other); end
  def all_requirements; end
  def conflicting_requirements; end
  def conflicting_requirements=(_); end
  def requirement_tree; end
  def requirement_tree=(_); end
  def requirement_trees; end
  def requirement_trees=(_); end
  def requirements_unwound_to_instead; end
  def requirements_unwound_to_instead=(_); end
  def reversed_requirement_tree_index; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def state_index; end
  def state_index=(_); end
  def state_requirement; end
  def state_requirement=(_); end
  def sub_dependencies_to_avoid; end
  def unwinding_to_primary_requirement?; end
  include Comparable
end
module Bundler::Molinillo::UI
  def after_resolution; end
  def before_resolution; end
  def debug(depth = nil); end
  def debug?; end
  def indicate_progress; end
  def output; end
  def progress_rate; end
end
class Bundler::Resolver
  def after_resolution; end
  def amount_constrained(dependency); end
  def before_resolution; end
  def debug(depth = nil); end
  def debug?; end
  def dependencies_for(specification); end
  def formatted_versions_with_platforms(versions_with_platforms); end
  def index_for(dependency); end
  def indicate_progress; end
  def initialize(index, source_requirements, base, gem_version_promoter, additional_base_requirements, platforms); end
  def name_for(dependency); end
  def name_for_explicit_dependency_source; end
  def name_for_locking_dependency_source; end
  def relevant_sources_for_vertex(vertex); end
  def requirement_satisfied_by?(requirement, activated, spec); end
  def search_for(dependency); end
  def self.platform_sort_key(platform); end
  def self.resolve(requirements, index, source_requirements = nil, base = nil, gem_version_promoter = nil, additional_base_requirements = nil, platforms = nil); end
  def self.sort_platforms(platforms); end
  def sort_dependencies(dependencies, activated, conflicts); end
  def start(requirements); end
  def verify_gemfile_dependencies_are_found!(requirements); end
  def version_conflict_message(e); end
  include Bundler::Molinillo::SpecificationProvider
  include Bundler::Molinillo::UI
end
class Bundler::Resolver::SpecGroup
  def ==(other); end
  def __dependencies; end
  def activate_platform!(platform); end
  def dependencies_for_activated_platforms; end
  def eql?(other); end
  def for?(platform); end
  def hash; end
  def ignores_bundler_dependencies; end
  def ignores_bundler_dependencies=(arg0); end
  def initialize(all_specs); end
  def metadata_dependencies(spec, platform); end
  def name; end
  def name=(arg0); end
  def source; end
  def source=(arg0); end
  def to_s; end
  def to_specs; end
  def version; end
  def version=(arg0); end
  include Bundler::GemHelpers
end
class Bundler::Source::Gemspec < Bundler::Source::Path
  def as_path_source; end
  def gemspec; end
  def initialize(options); end
end
class Bundler::Runtime
  def cache(custom_path = nil); end
  def check_for_activated_spec!(spec); end
  def clean(dry_run = nil); end
  def current_dependencies; end
  def dependencies; end
  def gems; end
  def initialize(root, definition); end
  def lock(opts = nil); end
  def prune_cache(cache_path); end
  def prune_gem_cache(resolve, cache_path); end
  def prune_git_and_path_cache(resolve, cache_path); end
  def remove_dir(dir, dry_run); end
  def requested_specs; end
  def require(*groups); end
  def requires; end
  def self.definition_method(meth); end
  def setup(*groups); end
  def setup_manpath; end
  def specs; end
  include Bundler::SharedHelpers
end
class Bundler::DepProxy
  def ==(other); end
  def __platform; end
  def dep; end
  def eql?(other); end
  def hash; end
  def initialize(dep, platform); end
  def method_missing(*args, &blk); end
  def name; end
  def requirement; end
  def to_s; end
  def type; end
end
module Bundler::UI
end
class Bundler::UI::Silent
  def add_color(string, color); end
  def ask(message); end
  def confirm(message, newline = nil); end
  def debug(message, newline = nil); end
  def debug?; end
  def error(message, newline = nil); end
  def info(message, newline = nil); end
  def initialize; end
  def level(name = nil); end
  def level=(name); end
  def no?; end
  def quiet?; end
  def shell=(arg0); end
  def silence; end
  def trace(message, newline = nil, force = nil); end
  def unprinted_warnings; end
  def warn(message, newline = nil); end
  def yes?(msg); end
end
class Bundler::UI::RGProxy < Gem::SilentUI
  def initialize(ui); end
  def say(message); end
end
class Bundler::RemoteSpecification
  def <=>(other); end
  def __swap__(spec); end
  def _remote_specification; end
  def dependencies; end
  def dependencies=(arg0); end
  def fetch_platform; end
  def full_name; end
  def git_version; end
  def initialize(name, version, platform, spec_fetcher); end
  def method_missing(method, *args, &blk); end
  def name; end
  def platform; end
  def remote; end
  def remote=(arg0); end
  def respond_to?(method, include_all = nil); end
  def sort_obj; end
  def source; end
  def source=(arg0); end
  def to_ary; end
  def to_s; end
  def version; end
  include Bundler::MatchPlatform
  include Comparable
end
class Bundler::StubSpecification < Bundler::RemoteSpecification
  def _remote_specification; end
  def activated; end
  def activated=(activated); end
  def default_gem; end
  def full_gem_path; end
  def full_require_paths; end
  def ignored; end
  def ignored=(arg0); end
  def load_paths; end
  def loaded_from; end
  def matches_for_glob(glob); end
  def missing_extensions?; end
  def raw_require_paths; end
  def self.from_stub(stub); end
  def source=(source); end
  def stub; end
  def stub=(arg0); end
  def to_yaml; end
end
class Bundler::EndpointSpecification < Gem::Specification
  def __swap__(spec); end
  def _local_specification; end
  def bindir; end
  def build_dependency(name, requirements); end
  def checksum; end
  def dependencies; end
  def dependencies=(arg0); end
  def executables; end
  def extensions; end
  def fetch_platform; end
  def initialize(name, version, platform, dependencies, metadata = nil); end
  def load_paths; end
  def local_specification_path; end
  def name; end
  def parse_metadata(data); end
  def platform; end
  def post_install_message; end
  def remote; end
  def remote=(arg0); end
  def require_paths; end
  def required_ruby_version; end
  def required_rubygems_version; end
  def source; end
  def source=(arg0); end
  def version; end
  include Bundler::MatchPlatform
end
class Bundler::RubyVersion
  def ==(other); end
  def diff(other); end
  def engine; end
  def engine_gem_version; end
  def engine_versions; end
  def exact?; end
  def gem_version; end
  def host; end
  def initialize(versions, patchlevel, engine, engine_version); end
  def matches?(requirements, version); end
  def patchlevel; end
  def self.from_string(string); end
  def self.system; end
  def single_version_string; end
  def to_gem_version_with_patchlevel; end
  def to_s(versions = nil); end
  def versions; end
  def versions_string(versions); end
end
module Gem::Ext
end
module Kernel
  def self.gem(dep, *reqs); end
end
